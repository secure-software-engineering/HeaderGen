from tensorflow.python.eager import context as context
from tensorflow.python.framework import dtypes as dtypes, ops as ops
from tensorflow.python.keras import backend as backend
from tensorflow.python.keras.engine import base_layer as base_layer, base_layer_utils as base_layer_utils, input_spec as input_spec, training as training_lib, training_utils as training_utils
from tensorflow.python.keras.saving.saved_model import network_serialization as network_serialization
from tensorflow.python.keras.utils import generic_utils as generic_utils, tf_inspect as tf_inspect, tf_utils as tf_utils
from tensorflow.python.ops import array_ops as array_ops, math_ops as math_ops
from tensorflow.python.util import nest as nest
from tensorflow.tools.docs import doc_controls as doc_controls
from typing import Any

class Functional(training_lib.Model):
    def __init__(self, inputs, outputs, name: Any | None = ..., trainable: bool = ..., **kwargs) -> None: ...
    @property
    def input(self): ...
    @property
    def input_shape(self): ...
    @property
    def input_spec(self): ...
    @input_spec.setter
    def input_spec(self, value) -> None: ...
    @property
    def output(self): ...
    @property
    def output_shape(self): ...
    def compute_mask(self, inputs, mask): ...
    def call(self, inputs, training: Any | None = ..., mask: Any | None = ...): ...
    def compute_output_shape(self, input_shape): ...
    def get_config(self): ...
    @classmethod
    def from_config(cls, config, custom_objects: Any | None = ...): ...

def connect_ancillary_layers(model, created_layers): ...
def reconstruct_from_config(config, custom_objects: Any | None = ..., created_layers: Any | None = ...): ...
def get_network_config(network, serialize_layer_fn: Any | None = ...): ...
def shape_with_no_batch_size(x): ...

class ModuleWrapper(base_layer.Layer):
    def __init__(self, module, method_name: Any | None = ..., **kwargs) -> None: ...
    def call(self, *args, **kwargs): ...
